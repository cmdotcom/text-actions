"use strict";
/**
 * Bulk SMS API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessagesApi = exports.MessagesApiApiKeys = exports.VoidAuth = exports.OAuth = exports.ApiKeyAuth = exports.HttpBasicAuth = exports.Recipient = exports.MessagesResponse = exports.Messages = exports.MessageResponse = exports.MessageEnvelope = exports.MessageBody = exports.Message = exports.Authentication = exports.WhatsappTemplate = exports.ComponentParameter = exports.Component = exports.ViewLocation = exports.Template = exports.Suggestion = exports.ShareLocation = exports.RichMessage = exports.RichContent = exports.RichCard = exports.Payment = exports.OAuthMessage = exports.Media = exports.LocalizableParam = exports.LineItem = exports.Language = exports.Dial = exports.ContactUrl = exports.ContactPhoneNumber = exports.ContactOrganization = exports.ContactName = exports.ContactEmail = exports.ContactAddress = exports.Contact = exports.Carousel = exports.CalendarPicker = exports.Calendar = void 0;
var localVarRequest = require("request");
var Promise = require("bluebird");
var defaultBasePath = 'https://gw.cmtelecom.com';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
var primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
var ObjectSerializer = /** @class */ (function () {
    function ObjectSerializer() {
    }
    ObjectSerializer.findCorrectType = function (data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            var discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    };
    ObjectSerializer.serialize = function (data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            var subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            var transformedData = [];
            for (var index in data) {
                var date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            var attributeTypes = typeMap[type].getAttributeTypeMap();
            var instance = {};
            for (var index in attributeTypes) {
                var attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    };
    ObjectSerializer.deserialize = function (data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            var subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            var transformedData = [];
            for (var index in data) {
                var date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            var instance = new typeMap[type]();
            var attributeTypes = typeMap[type].getAttributeTypeMap();
            for (var index in attributeTypes) {
                var attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    };
    return ObjectSerializer;
}());
/**
* Contains information for a {CM.Messaging.RCSModels.Models.Suggestion.Calendar} (RCS).
*/
var Calendar = /** @class */ (function () {
    function Calendar() {
    }
    Calendar.getAttributeTypeMap = function () {
        return Calendar.attributeTypeMap;
    };
    Calendar.discriminator = undefined;
    Calendar.attributeTypeMap = [
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }
    ];
    return Calendar;
}());
exports.Calendar = Calendar;
/**
* Options to select a calendar
*/
var CalendarPicker = /** @class */ (function () {
    function CalendarPicker() {
    }
    CalendarPicker.getAttributeTypeMap = function () {
        return CalendarPicker.attributeTypeMap;
    };
    CalendarPicker.discriminator = undefined;
    CalendarPicker.attributeTypeMap = [
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<Calendar>"
        }
    ];
    return CalendarPicker;
}());
exports.CalendarPicker = CalendarPicker;
/**
* A carousel contains two or more RichCards
*/
var Carousel = /** @class */ (function () {
    function Carousel() {
    }
    Carousel.getAttributeTypeMap = function () {
        return Carousel.attributeTypeMap;
    };
    Carousel.discriminator = undefined;
    Carousel.attributeTypeMap = [
        {
            "name": "cardWidth",
            "baseName": "cardWidth",
            "type": "Carousel.CardWidthEnum"
        },
        {
            "name": "cards",
            "baseName": "cards",
            "type": "Array<RichCard>"
        }
    ];
    return Carousel;
}());
exports.Carousel = Carousel;
(function (Carousel) {
    var CardWidthEnum;
    (function (CardWidthEnum) {
        CardWidthEnum[CardWidthEnum["Small"] = 'Small'] = "Small";
        CardWidthEnum[CardWidthEnum["Medium"] = 'Medium'] = "Medium";
    })(CardWidthEnum = Carousel.CardWidthEnum || (Carousel.CardWidthEnum = {}));
})(Carousel = exports.Carousel || (exports.Carousel = {}));
exports.Carousel = Carousel;
/**
* Represents 1 contact
*/
var Contact = /** @class */ (function () {
    function Contact() {
    }
    Contact.getAttributeTypeMap = function () {
        return Contact.attributeTypeMap;
    };
    Contact.discriminator = undefined;
    Contact.attributeTypeMap = [
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<ContactAddress>"
        },
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<ContactEmail>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "ContactName"
        },
        {
            "name": "org",
            "baseName": "org",
            "type": "ContactOrganization"
        },
        {
            "name": "phones",
            "baseName": "phones",
            "type": "Array<ContactPhoneNumber>"
        },
        {
            "name": "urls",
            "baseName": "urls",
            "type": "Array<ContactUrl>"
        }
    ];
    return Contact;
}());
exports.Contact = Contact;
/**
* One address of a contact  See also https://developers.facebook.com/docs/whatsapp/api/messages/others#contacts
*/
var ContactAddress = /** @class */ (function () {
    function ContactAddress() {
    }
    ContactAddress.getAttributeTypeMap = function () {
        return ContactAddress.attributeTypeMap;
    };
    ContactAddress.discriminator = undefined;
    ContactAddress.attributeTypeMap = [
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "zip",
            "baseName": "zip",
            "type": "string"
        }
    ];
    return ContactAddress;
}());
exports.ContactAddress = ContactAddress;
/**
* Contact email address  See also https://developers.facebook.com/docs/whatsapp/api/messages/others#contacts
*/
var ContactEmail = /** @class */ (function () {
    function ContactEmail() {
    }
    ContactEmail.getAttributeTypeMap = function () {
        return ContactEmail.attributeTypeMap;
    };
    ContactEmail.discriminator = undefined;
    ContactEmail.attributeTypeMap = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];
    return ContactEmail;
}());
exports.ContactEmail = ContactEmail;
/**
* The name of a contact.  See also https://developers.facebook.com/docs/whatsapp/api/messages/others#contacts
*/
var ContactName = /** @class */ (function () {
    function ContactName() {
    }
    ContactName.getAttributeTypeMap = function () {
        return ContactName.attributeTypeMap;
    };
    ContactName.discriminator = undefined;
    ContactName.attributeTypeMap = [
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middle_name",
            "type": "string"
        },
        {
            "name": "namePrefix",
            "baseName": "name_prefix",
            "type": "string"
        },
        {
            "name": "nameSuffix",
            "baseName": "name_suffix",
            "type": "string"
        },
        {
            "name": "formattedName",
            "baseName": "formatted_name",
            "type": "string"
        }
    ];
    return ContactName;
}());
exports.ContactName = ContactName;
/**
* The organization of a contact  See also https://developers.facebook.com/docs/whatsapp/api/messages/others#contacts
*/
var ContactOrganization = /** @class */ (function () {
    function ContactOrganization() {
    }
    ContactOrganization.getAttributeTypeMap = function () {
        return ContactOrganization.attributeTypeMap;
    };
    ContactOrganization.discriminator = undefined;
    ContactOrganization.attributeTypeMap = [
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "department",
            "baseName": "department",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }
    ];
    return ContactOrganization;
}());
exports.ContactOrganization = ContactOrganization;
/**
* Phone number of a contact
*/
var ContactPhoneNumber = /** @class */ (function () {
    function ContactPhoneNumber() {
    }
    ContactPhoneNumber.getAttributeTypeMap = function () {
        return ContactPhoneNumber.attributeTypeMap;
    };
    ContactPhoneNumber.discriminator = undefined;
    ContactPhoneNumber.attributeTypeMap = [
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];
    return ContactPhoneNumber;
}());
exports.ContactPhoneNumber = ContactPhoneNumber;
/**
* An Url for a contact  See also https://developers.facebook.com/docs/whatsapp/api/messages/others#contacts
*/
var ContactUrl = /** @class */ (function () {
    function ContactUrl() {
    }
    ContactUrl.getAttributeTypeMap = function () {
        return ContactUrl.attributeTypeMap;
    };
    ContactUrl.discriminator = undefined;
    ContactUrl.attributeTypeMap = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];
    return ContactUrl;
}());
exports.ContactUrl = ContactUrl;
/**
* Contains information for a {CM.Messaging.RCSModels.Models.Suggestion.Dial}
*/
var Dial = /** @class */ (function () {
    function Dial() {
    }
    Dial.getAttributeTypeMap = function () {
        return Dial.attributeTypeMap;
    };
    Dial.discriminator = undefined;
    Dial.attributeTypeMap = [
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }
    ];
    return Dial;
}());
exports.Dial = Dial;
/**
* Source: https://developers.facebook.com/docs/whatsapp/api/messages/message-templates  The language parameter sets the language policy for an Message Template;  you can set it to either fallback or deterministic.
*/
var Language = /** @class */ (function () {
    function Language() {
    }
    Language.getAttributeTypeMap = function () {
        return Language.attributeTypeMap;
    };
    Language.discriminator = undefined;
    Language.attributeTypeMap = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "policy",
            "baseName": "policy",
            "type": "string"
        }
    ];
    return Language;
}());
exports.Language = Language;
var LineItem = /** @class */ (function () {
    function LineItem() {
    }
    LineItem.getAttributeTypeMap = function () {
        return LineItem.attributeTypeMap;
    };
    LineItem.discriminator = undefined;
    LineItem.attributeTypeMap = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "subText",
            "baseName": "subText",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        }
    ];
    return LineItem;
}());
exports.LineItem = LineItem;
/**
* Source: https://developers.facebook.com/docs/whatsapp/api/messages/message-templates  This field is an array of values to apply to variables in the template
*/
var LocalizableParam = /** @class */ (function () {
    function LocalizableParam() {
    }
    LocalizableParam.getAttributeTypeMap = function () {
        return LocalizableParam.attributeTypeMap;
    };
    LocalizableParam.discriminator = undefined;
    LocalizableParam.attributeTypeMap = [
        {
            "name": "_default",
            "baseName": "default",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "any"
        },
        {
            "name": "dateTime",
            "baseName": "date_time",
            "type": "any"
        }
    ];
    return LocalizableParam;
}());
exports.LocalizableParam = LocalizableParam;
/**
* Object containing information about an image, a video, an audio file or a document.
*/
var Media = /** @class */ (function () {
    function Media() {
    }
    Media.getAttributeTypeMap = function () {
        return Media.attributeTypeMap;
    };
    Media.discriminator = undefined;
    Media.attributeTypeMap = [
        {
            "name": "mediaName",
            "baseName": "mediaName",
            "type": "string"
        },
        {
            "name": "mediaUri",
            "baseName": "mediaUri",
            "type": "string"
        },
        {
            "name": "mimeType",
            "baseName": "mimeType",
            "type": "string"
        }
    ];
    return Media;
}());
exports.Media = Media;
var OAuthMessage = /** @class */ (function () {
    function OAuthMessage() {
    }
    OAuthMessage.getAttributeTypeMap = function () {
        return OAuthMessage.attributeTypeMap;
    };
    OAuthMessage.discriminator = undefined;
    OAuthMessage.attributeTypeMap = [
        {
            "name": "responseType",
            "baseName": "responseType",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "responseEncryptionKey",
            "baseName": "responseEncryptionKey",
            "type": "string"
        },
        {
            "name": "clientSecret",
            "baseName": "clientSecret",
            "type": "string"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "Array<string>"
        }
    ];
    return OAuthMessage;
}());
exports.OAuthMessage = OAuthMessage;
var Payment = /** @class */ (function () {
    function Payment() {
    }
    Payment.getAttributeTypeMap = function () {
        return Payment.attributeTypeMap;
    };
    Payment.discriminator = undefined;
    Payment.attributeTypeMap = [
        {
            "name": "merchantIdentifier",
            "baseName": "merchantIdentifier",
            "type": "string"
        },
        {
            "name": "merchantName",
            "baseName": "merchantName",
            "type": "string"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<LineItem>"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "countryCodes",
            "baseName": "countryCodes",
            "type": "Array<string>"
        },
        {
            "name": "billingAddressRequired",
            "baseName": "billingAddressRequired",
            "type": "boolean"
        },
        {
            "name": "shippingContactRequired",
            "baseName": "shippingContactRequired",
            "type": "boolean"
        },
        {
            "name": "merchantSession",
            "baseName": "merchantSession",
            "type": "any"
        }
    ];
    return Payment;
}());
exports.Payment = Payment;
/**
* A rich card, which can be used to display media, text and images in RCS
*/
var RichCard = /** @class */ (function () {
    function RichCard() {
    }
    RichCard.getAttributeTypeMap = function () {
        return RichCard.attributeTypeMap;
    };
    RichCard.discriminator = undefined;
    RichCard.attributeTypeMap = [
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "media",
            "baseName": "media",
            "type": "Media"
        },
        {
            "name": "suggestions",
            "baseName": "suggestions",
            "type": "Array<Suggestion>"
        }
    ];
    return RichCard;
}());
exports.RichCard = RichCard;
var RichContent = /** @class */ (function () {
    function RichContent() {
    }
    RichContent.getAttributeTypeMap = function () {
        return RichContent.attributeTypeMap;
    };
    RichContent.discriminator = undefined;
    RichContent.attributeTypeMap = [
        {
            "name": "conversation",
            "baseName": "conversation",
            "type": "Array<RichMessage>"
        },
        {
            "name": "suggestions",
            "baseName": "suggestions",
            "type": "Array<Suggestion>"
        }
    ];
    return RichContent;
}());
exports.RichContent = RichContent;
/**
* A regular text message, replaces the Msg Body for channels  that support rich content (all channels except SMS, Voice  and Push at this moment)
*/
var RichMessage = /** @class */ (function () {
    function RichMessage() {
    }
    RichMessage.getAttributeTypeMap = function () {
        return RichMessage.attributeTypeMap;
    };
    RichMessage.discriminator = undefined;
    RichMessage.attributeTypeMap = [
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "media",
            "baseName": "media",
            "type": "Media"
        },
        {
            "name": "carousel",
            "baseName": "carousel",
            "type": "Carousel"
        },
        {
            "name": "suggestions",
            "baseName": "suggestions",
            "type": "Array<Suggestion>"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "Template"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "ViewLocation"
        },
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "Array<Contact>"
        },
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "OAuthMessage"
        }
    ];
    return RichMessage;
}());
exports.RichMessage = RichMessage;
/**
* Requests the received to share his/her location
*/
var ShareLocation = /** @class */ (function () {
    function ShareLocation() {
    }
    ShareLocation.getAttributeTypeMap = function () {
        return ShareLocation.attributeTypeMap;
    };
    ShareLocation.discriminator = undefined;
    ShareLocation.attributeTypeMap = [
        {
            "name": "requestLocation",
            "baseName": "RequestLocation",
            "type": "boolean"
        }
    ];
    return ShareLocation;
}());
exports.ShareLocation = ShareLocation;
/**
* Represents a suggestion to send to the user
*/
var Suggestion = /** @class */ (function () {
    function Suggestion() {
    }
    Suggestion.getAttributeTypeMap = function () {
        return Suggestion.attributeTypeMap;
    };
    Suggestion.discriminator = undefined;
    Suggestion.attributeTypeMap = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "postbackdata",
            "baseName": "postbackdata",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "calendar",
            "baseName": "calendar",
            "type": "Calendar"
        },
        {
            "name": "calendarPicker",
            "baseName": "calendarPicker",
            "type": "CalendarPicker"
        },
        {
            "name": "dial",
            "baseName": "dial",
            "type": "Dial"
        },
        {
            "name": "viewLocation",
            "baseName": "viewLocation",
            "type": "ViewLocation"
        },
        {
            "name": "shareLocation",
            "baseName": "shareLocation",
            "type": "ShareLocation"
        },
        {
            "name": "media",
            "baseName": "media",
            "type": "Media"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment"
        }
    ];
    return Suggestion;
}());
exports.Suggestion = Suggestion;
/**
* Used to send a template message, at this moment only supported in WhatsApp
*/
var Template = /** @class */ (function () {
    function Template() {
    }
    Template.getAttributeTypeMap = function () {
        return Template.attributeTypeMap;
    };
    Template.discriminator = undefined;
    Template.attributeTypeMap = [
        {
            "name": "whatsapp",
            "baseName": "whatsapp",
            "type": "WhatsappTemplate"
        }
    ];
    return Template;
}());
exports.Template = Template;
/**
* A location in a message or suggestion.
*/
var ViewLocation = /** @class */ (function () {
    function ViewLocation() {
    }
    ViewLocation.getAttributeTypeMap = function () {
        return ViewLocation.attributeTypeMap;
    };
    ViewLocation.discriminator = undefined;
    ViewLocation.attributeTypeMap = [
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "searchQuery",
            "baseName": "searchQuery",
            "type": "string"
        },
        {
            "name": "radius",
            "baseName": "radius",
            "type": "number"
        }
    ];
    return ViewLocation;
}());
exports.ViewLocation = ViewLocation;
/**
* Dynamic content of the message. Separated in in different sections.
*/
var Component = /** @class */ (function () {
    function Component() {
    }
    Component.getAttributeTypeMap = function () {
        return Component.attributeTypeMap;
    };
    Component.discriminator = undefined;
    Component.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<ComponentParameter>"
        }
    ];
    return Component;
}());
exports.Component = Component;
/**
* Dynamic content of a media template message.
*/
var ComponentParameter = /** @class */ (function () {
    function ComponentParameter() {
    }
    ComponentParameter.getAttributeTypeMap = function () {
        return ComponentParameter.attributeTypeMap;
    };
    ComponentParameter.discriminator = undefined;
    ComponentParameter.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Media"
        },
        {
            "name": "document",
            "baseName": "document",
            "type": "Media"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "any"
        },
        {
            "name": "dateTime",
            "baseName": "date_time",
            "type": "any"
        }
    ];
    return ComponentParameter;
}());
exports.ComponentParameter = ComponentParameter;
/**
* Whatsapp template, see https://developers.facebook.com/docs/whatsapp/api/messages/message-templates  for more information
*/
var WhatsappTemplate = /** @class */ (function () {
    function WhatsappTemplate() {
    }
    WhatsappTemplate.getAttributeTypeMap = function () {
        return WhatsappTemplate.attributeTypeMap;
    };
    WhatsappTemplate.discriminator = undefined;
    WhatsappTemplate.attributeTypeMap = [
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "elementName",
            "baseName": "element_name",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "Language"
        },
        {
            "name": "localizableParams",
            "baseName": "localizable_params",
            "type": "Array<LocalizableParam>"
        },
        {
            "name": "components",
            "baseName": "components",
            "type": "Array<Component>"
        }
    ];
    return WhatsappTemplate;
}());
exports.WhatsappTemplate = WhatsappTemplate;
/**
* Authentication
*/
var Authentication = /** @class */ (function () {
    function Authentication() {
    }
    Authentication.getAttributeTypeMap = function () {
        return Authentication.attributeTypeMap;
    };
    Authentication.discriminator = undefined;
    Authentication.attributeTypeMap = [
        {
            "name": "productToken",
            "baseName": "productToken",
            "type": "string"
        }
    ];
    return Authentication;
}());
exports.Authentication = Authentication;
/**
* The message
*/
var Message = /** @class */ (function () {
    function Message() {
    }
    Message.getAttributeTypeMap = function () {
        return Message.attributeTypeMap;
    };
    Message.discriminator = undefined;
    Message.attributeTypeMap = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "MessageBody"
        },
        {
            "name": "minimumNumberOfMessageParts",
            "baseName": "minimumNumberOfMessageParts",
            "type": "number"
        },
        {
            "name": "maximumNumberOfMessageParts",
            "baseName": "maximumNumberOfMessageParts",
            "type": "number"
        },
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<Recipient>"
        },
        {
            "name": "customGrouping",
            "baseName": "customGrouping",
            "type": "string"
        },
        {
            "name": "allowedChannels",
            "baseName": "allowedChannels",
            "type": "Array<string>"
        },
        {
            "name": "richContent",
            "baseName": "richContent",
            "type": "RichContent"
        }
    ];
    return Message;
}());
exports.Message = Message;
/**
* Contains the body of the message.
*/
var MessageBody = /** @class */ (function () {
    function MessageBody() {
    }
    MessageBody.getAttributeTypeMap = function () {
        return MessageBody.attributeTypeMap;
    };
    MessageBody.discriminator = undefined;
    MessageBody.attributeTypeMap = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];
    return MessageBody;
}());
exports.MessageBody = MessageBody;
/**
* Envelope containing messages and authentication
*/
var MessageEnvelope = /** @class */ (function () {
    function MessageEnvelope() {
    }
    MessageEnvelope.getAttributeTypeMap = function () {
        return MessageEnvelope.attributeTypeMap;
    };
    MessageEnvelope.discriminator = undefined;
    MessageEnvelope.attributeTypeMap = [
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Messages"
        }
    ];
    return MessageEnvelope;
}());
exports.MessageEnvelope = MessageEnvelope;
/**
* Response for an individual message
*/
var MessageResponse = /** @class */ (function () {
    function MessageResponse() {
    }
    MessageResponse.getAttributeTypeMap = function () {
        return MessageResponse.attributeTypeMap;
    };
    MessageResponse.discriminator = undefined;
    MessageResponse.attributeTypeMap = [
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "parts",
            "baseName": "parts",
            "type": "number"
        },
        {
            "name": "messageDetails",
            "baseName": "messageDetails",
            "type": "string"
        },
        {
            "name": "messageErrorCode",
            "baseName": "messageErrorCode",
            "type": "number"
        }
    ];
    return MessageResponse;
}());
exports.MessageResponse = MessageResponse;
/**
* The message(s) to send
*/
var Messages = /** @class */ (function () {
    function Messages() {
    }
    Messages.getAttributeTypeMap = function () {
        return Messages.attributeTypeMap;
    };
    Messages.discriminator = undefined;
    Messages.attributeTypeMap = [
        {
            "name": "authentication",
            "baseName": "authentication",
            "type": "Authentication"
        },
        {
            "name": "msg",
            "baseName": "msg",
            "type": "Array<Message>"
        }
    ];
    return Messages;
}());
exports.Messages = Messages;
/**
* Response from a Message POST
*/
var MessagesResponse = /** @class */ (function () {
    function MessagesResponse() {
    }
    MessagesResponse.getAttributeTypeMap = function () {
        return MessagesResponse.attributeTypeMap;
    };
    MessagesResponse.discriminator = undefined;
    MessagesResponse.attributeTypeMap = [
        {
            "name": "details",
            "baseName": "details",
            "type": "string"
        },
        {
            "name": "errorCode",
            "baseName": "errorCode",
            "type": "number"
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<MessageResponse>"
        }
    ];
    return MessagesResponse;
}());
exports.MessagesResponse = MessagesResponse;
/**
* Contains the  mobile number in international format.
*/
var Recipient = /** @class */ (function () {
    function Recipient() {
    }
    Recipient.getAttributeTypeMap = function () {
        return Recipient.attributeTypeMap;
    };
    Recipient.discriminator = undefined;
    Recipient.attributeTypeMap = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }
    ];
    return Recipient;
}());
exports.Recipient = Recipient;
var enumsMap = {
    "Carousel.CardWidthEnum": Carousel.CardWidthEnum,
};
var typeMap = {
    "Calendar": Calendar,
    "CalendarPicker": CalendarPicker,
    "Carousel": Carousel,
    "Contact": Contact,
    "ContactAddress": ContactAddress,
    "ContactEmail": ContactEmail,
    "ContactName": ContactName,
    "ContactOrganization": ContactOrganization,
    "ContactPhoneNumber": ContactPhoneNumber,
    "ContactUrl": ContactUrl,
    "Dial": Dial,
    "Language": Language,
    "LineItem": LineItem,
    "LocalizableParam": LocalizableParam,
    "Media": Media,
    "OAuthMessage": OAuthMessage,
    "Payment": Payment,
    "RichCard": RichCard,
    "RichContent": RichContent,
    "RichMessage": RichMessage,
    "ShareLocation": ShareLocation,
    "Suggestion": Suggestion,
    "Template": Template,
    "ViewLocation": ViewLocation,
    "WhatsappTemplate": WhatsappTemplate,
    "Authentication": Authentication,
    "Message": Message,
    "MessageBody": MessageBody,
    "MessageEnvelope": MessageEnvelope,
    "MessageResponse": MessageResponse,
    "Messages": Messages,
    "MessagesResponse": MessagesResponse,
    "Recipient": Recipient,
};
var HttpBasicAuth = /** @class */ (function () {
    function HttpBasicAuth() {
        this.username = '';
        this.password = '';
    }
    HttpBasicAuth.prototype.applyToRequest = function (requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    };
    return HttpBasicAuth;
}());
exports.HttpBasicAuth = HttpBasicAuth;
var ApiKeyAuth = /** @class */ (function () {
    function ApiKeyAuth(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    ApiKeyAuth.prototype.applyToRequest = function (requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    };
    return ApiKeyAuth;
}());
exports.ApiKeyAuth = ApiKeyAuth;
var OAuth = /** @class */ (function () {
    function OAuth() {
        this.accessToken = '';
    }
    OAuth.prototype.applyToRequest = function (requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    };
    return OAuth;
}());
exports.OAuth = OAuth;
var VoidAuth = /** @class */ (function () {
    function VoidAuth() {
        this.username = '';
        this.password = '';
    }
    VoidAuth.prototype.applyToRequest = function (_) {
        // Do nothing
    };
    return VoidAuth;
}());
exports.VoidAuth = VoidAuth;
var MessagesApiApiKeys;
(function (MessagesApiApiKeys) {
})(MessagesApiApiKeys = exports.MessagesApiApiKeys || (exports.MessagesApiApiKeys = {}));
var MessagesApi = /** @class */ (function () {
    function MessagesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(MessagesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MessagesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: false,
        configurable: true
    });
    MessagesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    MessagesApi.prototype.setApiKey = function (key, value) {
        this.authentications[MessagesApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * @summary CM's Messaging Gateway enables you to send text messages to mobile phones all around the world in very high volume.                            The Messaging Gateway API covers the interface between your application and the CM Platform by means of the HTTP protocol. Only bulk (free of charge for the end user) text messages are supported.
     * @param message
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.messagesSendMessage = function (message, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v1.0/message';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling messagesSendMessage.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(message, "MessageEnvelope")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MessagesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return MessagesApi;
}());
exports.MessagesApi = MessagesApi;
//# sourceMappingURL=api.js.map